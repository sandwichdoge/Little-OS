#include "interrupt.h"

#include "builddef.h"
#include "drivers/ioapic.h"
#include "drivers/lapic.h"
#include "drivers/pic.h"
#include "panic.h"
#include "smp.h"
#include "utils/debug.h"

#define IDT_SIZE 256

extern void asm_int_handler_32();   // Handler for PIT channel0 system timer
extern void asm_int_handler_33();   // Handler for keyboard press
extern void asm_int_handler_36();   // Handler for com1
extern void asm_int_handler_39();   // Handler for device not available4
extern void asm_int_handler_15();   // Handler for APIC spurious irqs
extern void asm_int_handler_14();   // Handler for page fault
extern void asm_int_handler_13();   // Handler for general protection fault
extern void asm_int_handler_128();  // Handler for syscall

struct idt IDT;                                  // To be loaded into the CPU
struct idt_entry idt_entries[IDT_SIZE] = {{0}};  // Main content of IDT
// Array of void func(uint*, cpu_state*) pointers
void (*int_handler_table[IDT_SIZE])(size_t* return_reg, struct cpu_state*) = {0};

public
struct idt * interrupt_get_idt() {
    return &IDT;
}

// https://wiki.osdev.org/Interrupt_Descriptor_Table
private
void interrupt_encode_idt_entry(uint32_t interrupt_num, size_t f_ptr_handler) {
    idt_entries[interrupt_num].offset_low = f_ptr_handler & 0xffff;
    idt_entries[interrupt_num].offset_high = (f_ptr_handler >> 16) & 0xffff;

    idt_entries[interrupt_num].segment_selector = 0x8;  // code segment in gdt
    idt_entries[interrupt_num].reserved = 0x0;

    idt_entries[interrupt_num].type_and_attr = (1 << 7) |             // P
                                               (0 << 6) | (0 << 5) |  // DPL
                                               (0 << 4) |             // S
                                               0xe;                   // 32-bit interrupt gate - 0b1110
}

private
void lidt(struct idt* idt_r) { asm("lidt %0" ::"m"(*idt_r)); }

private
void ISR_GPF(size_t* return_reg, struct cpu_state* unused) {
    _dbg_log("General Protection Fault!\n");
    panic();
}

// Determine whether an interrupt is from external hardware, or generated by CPU.
private
int is_hw_irq(uint32_t irq) { return (irq == INT_SYSTIME || irq == INT_KEYBOARD || irq == INT_COM1); }

public
void interrupt_register(uint32_t irq, void (*isr)(size_t* return_reg, struct cpu_state*)) {
    int_handler_table[irq] = isr;
    if (is_hw_irq(irq)) {
        _dbg_log("Enabling HW interrupt %u.\n", irq);
        if (is_ioapic_initialized()) {
            ioapic_redirect_external_int(irq - IRQ_REDIR_BASE, 0);
        } else {
            pic_enable_irq(irq - IRQ_REDIR_BASE);
        }
    }
}

private
void ISR_COM1(size_t* return_reg, struct cpu_state* unused) { _dbg_break(); }

private
void ISR_DEVICE_NOT_AVAILABLE(size_t* return_reg, struct cpu_state* unused) { _dbg_log("Device Not Available\n"); }

public
void interrupt_init(void) {
    pic_init();  // Programmable interrupt controller
    /*
    IRQ 0 ‒ system timer
    IRQ 1 — keyboard controller
    IRQ 3 — serial port COM2
    IRQ 4 — serial port COM1
    IRQ 5 — line print terminal 2
    IRQ 6 — floppy controller
    IRQ 7 — line print terminal 1
    IRQ 8 — RTC timer
    IRQ 12 — mouse controller
    IRQ 13 — math co-processor
    IRQ 14 — ATA channel 1
    IRQ 15 — ATA channel 2
    */

    // Must initialize all asm irq handlers that we'll use here.
    // Keyboard press interrupt, 0x20 + 1 (which is PIC1_START_INTERRUPT + IRQ_1)
    interrupt_encode_idt_entry(INT_GPF, (size_t)asm_int_handler_13);
    interrupt_encode_idt_entry(INT_PAGEFAULT, (size_t)asm_int_handler_14);
    interrupt_encode_idt_entry(INT_APIC_SPURIOUS, (size_t)asm_int_handler_15);
    interrupt_encode_idt_entry(INT_SYSTIME, (size_t)asm_int_handler_32);
    interrupt_encode_idt_entry(INT_KEYBOARD, (size_t)asm_int_handler_33);
    interrupt_encode_idt_entry(INT_COM1, (size_t)asm_int_handler_36);
    interrupt_encode_idt_entry(INT_DEVICE_NOT_AVAiLABLE, (size_t)asm_int_handler_39);
    interrupt_encode_idt_entry(INT_SYSCALL, (size_t)asm_int_handler_128);

    IDT.size = sizeof(struct idt_entry) * IDT_SIZE - 1;
    IDT.address = (size_t)idt_entries;

    lidt(&IDT);  // ASM wrapper, load interrupt table

    interrupt_register(INT_COM1, ISR_COM1);
    interrupt_register(INT_GPF, ISR_GPF);
    interrupt_register(INT_DEVICE_NOT_AVAiLABLE, ISR_DEVICE_NOT_AVAILABLE);
}

public
void interrupt_handler(size_t* return_reg, struct cpu_state cpu_state, uint32_t interrupt_num, struct stack_state stack_state) {
    if (interrupt_num >= sizeof(int_handler_table) / sizeof(*int_handler_table)) {
        _dbg_log("Error. Unknown interrupt number.\n");
        return;  // Stop if array out of range
    }
    
    if (is_ioapic_initialized()) {
        lapic_ack(lapic_get_base());
    } else {
        pic_ack(interrupt_num);
    }

    if (stack_state.error_code) {
        _dbg_log("[CPU%d][Interrupt]num:[%u]\n", smp_get_cpu_id(), interrupt_num);
        _dbg_log("Error code [0x%x]\n", stack_state.error_code);
        _dbg_log("Table [%d]\n", (stack_state.error_code >> 1) & 3);
        _dbg_log("Index [%x]\n", (stack_state.error_code >> 3) & 4095);
        _dbg_log("Fauling CS [0x%x]\n", stack_state.cs);
        _dbg_log("Faulting EIP: [0x%x]\n", stack_state.eip);
    }

    if (int_handler_table[interrupt_num]) {
        (*int_handler_table[interrupt_num])(return_reg, &cpu_state);
    } else {
        _dbg_log("Unhandled interrupt[%u]\n", interrupt_num);
    }
}
